<?php
class FileToken {
	//The following class uses a zip file template containing a folder and a pregenerated desktop.ini file.
	//It uses byte arrays in order to edit specific placeholders and then to create on-demand zip files without using 
	//any zip libraries. (only tested on Ubuntu 18.04 w/ php 7.2.24, and targeting Win 10 64 bits + Win Vista 32 bits)
	//This mecanism has some limitations, for example modifications of the byte arrays would require some code modifications since 
	//it uses some specific indexes of the arrays (CRC32, url etc...) which are hardcoded. 
	//TODO what about compressed and uncompressed size ? + check last answer here https://social.technet.microsoft.com/Forums/windows/en-US/5ffdee96-7bbe-4ed6-99b9-a2a69de12e00/cant-use-icons-for-shortcuts-from-network-in-windows-8?forum=w8itprogeneral
	
	private $desktop_ini_path = "/var/DL/desktop.ini"; //path to the desktop.ini file template
	private $save_path = "/var/DL/Privé";              //where to save generated folders
	private $tokenid;                                  //13 chars uniqid (autogenerated)
	private $splitter;                                 //5 chars splitter
	private $url = "trgrd.site";                       //x chars URL
	
	function __construct($splitter="23911") {
		$this->tokenid = $this->generateTokenID(array($splitter)); //todo something with array parameter not needed?
		$this->splitter = str_split(bin2hex($splitter), 2);
	}
	//ugly... could be done with pack/unpack instead, or PHP's ZipArchive lib, but it was unsuccessful at preserving desktop.ini system file attributes (not telling it's impossible...)
	private $desktop_byte_array_begin = [0xff,0xfe,0x0d,0x00,0x0a,0x00,0x5b,0x00,0x2e,0x00,0x53,0x00,0x68,0x00,0x65,0x00,0x6c,0x00,0x6c,0x00,0x43,0x00,0x6c,0x00,0x61,0x00,0x73,0x00,0x73,0x00,0x49,0x00,0x6e,0x00,0x66,0x00,0x6f,0x00,0x5d,0x00,0x0d,0x00,0x0a,0x00,0x49,0x00,0x63,0x00,0x6f,0x00,0x6e,0x00,0x52,0x00,0x65,0x00,0x73,0x00,0x6f,0x00,0x75,0x00,0x72,0x00,0x63,0x00,0x65,0x00,0x3d,0x00,0x5c,0x00,0x5c,0x00,0x25,0x00,0x55,0x00,0x53,0x00,0x45,0x00,0x52,0x00,0x4e,0x00,0x41,0x00,0x4d,0x00,0x45,0x00,0x25,0x00,0x2e,0x00,0x25,0x00,0x55,0x00,0x53,0x00,0x45,0x00,0x52,0x00,0x44,0x00,0x4f,0x00,0x4d,0x00,0x41,0x00,0x49,0x00,0x4e,0x00,0x25,0x00,0x2e,0x00,/*splitter.*/0x32,0x00,0x33,0x00,0x39,0x00,0x31,0x00,0x34,0x00,0x2e,0x00,/*uniqid*/0x41,0x00,0x41,0x00,0x41,0x00,0x41,0x00,0x41,0x00,0x41,0x00,0x41,0x00,0x41,0x00,0x41,0x00,0x41,0x00,0x41,0x00,0x41,0x00,0x41,0x00,0x2e,0x00]; /*here will be placed the chosen URL */

	private $desktop_byte_array_end = [/*\resource.dll*/0x5c,0x00,0x72,0x00,0x65,0x00,0x73,0x00,0x6f,0x00,0x75,0x00,0x72,0x00,0x63,0x00,0x65,0x00,0x2e,0x00,0x64,0x00,0x6c,0x00,0x6c,0x00,/*\r\n*/0x0d,0x00,0x0a,0x00];

	private $zip_byte_array_begin = [0x50,0x4b,0x03,0x04,0x0a,0x00,0x00,0x00,0x00,0x00,0x88,0x5c,0x5e,0x4b,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x07,0x00,0x00,0x00,0x53,0x65,0x63,0x72,0x65,0x74,0x2f,0x50,0x4b,0x03,0x04,0x0a,0x00,0x00,0x00,0x00,0x00,0x54,0x5e,0x5e,0x4b,/*crc32*/0x0c,0x27,0x16,0x2c,/*compressed size*/0xd2,0x00,0x00,0x00,/*uncompressed size*/0xd2,0x00,0x00,0x00,0x12,0x00,0x00,0x00,0x53,0x65,0x63,0x72,0x65,0x74,0x2f,0x64,0x65,0x73,0x6b,0x74,0x6f,0x70,0x2e,0x69,0x6e,0x69];
	//private $zip_byte_array_begin = [0x50,0x4b,0x03,0x04,0x0a,0x00,0x00,0x00,0x00,0x00,0x88,0x5c,0x5e,0x4b,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x06,0x00,0x10,0x00,0x50,0x72,0x69,0x76,0x82,0x2f,0x75,0x70,0x0c,0x00,0x01,0x00,0x71,0x68,0x8a,0x50,0x72,0x69,0x76,0xc3,0xa9,0x2f,0x50,0x4b,0x03,0x04,0x0a,0x00,0x00,0x00,0x00,0x00,0x54,0x5e,0x5e,0x4b,/*crc32*/0x0c,0x27,0x16,0x2c,/*compressed size*/0xd2,0x00,0x00,0x00,/*uncompressed size*/0xd2,0x00,0x00,0x00,0x11,0x00,0x1b,0x00,0x50,0x72,0x69,0x76,0x82,0x2f,0x64,0x65,0x73,0x6b,0x74,0x6f,0x70,0x2e,0x69,0x6e,0x69,0x75,0x70,0x17,0x00,0x01,0x98,0x92,0x8c,0x14,0x50,0x72,0x69,0x76,0xc3,0xa9,0x2f,0x64,0x65,0x73,0x6b,0x74,0x6f,0x70,0x2e,0x69,0x6e,0x69];
	private $zip_byte_array_end = [0x50,0x4b,0x01,0x02,/*version made by*/0x1f,0x00,/*min version needed*/0x0a,0x00,0x00,0x00,0x00,0x00,/*last mod time*/0x88,0x5c,/*last mod date*/0x5e,0x4b,/*CRC32*/0x00,0x00,0x00,0x00,/*compressed size*/0x00,0x00,0x00,0x00,/*uncompressed size*/0x00,0x00,0x00,0x00,/*filename length*/0x07,0x00,/*extra field*/0x24,0x00,/*file comment length*/0x00,0x00,/*extra*/0x00,0x00,0x00,0x00,0x14,0x00,0x00,0x00,0x00,0x00,0x00,0x00,/*dirname = Secret*/0x53,0x65,0x63,0x72,0x65,0x74,0x2f,0x0a,0x00,0x20,0x00,0x00,0x00,0x00,0x00,0x01,0x00,0x18,0x00,0x74,0x04,0xf8,0x1a,0xbd,0x80,0xd3,0x01,0x74,0x04,0xf8,0x1a,0xbd,0x80,0xd3,0x01,0x5c,0xb6,0xf7,0x1a,0xbd,0x80,0xd3,0x01,    0x50,0x4b,0x01,0x02,0x1f,0x00,0x0a,0x00,0x00,0x00,0x00,0x00,0x54,0x5e,0x5e,0x4b,/*CRC32*/0x0c,0x27,0x16,0x2c,/*compressed size*/0xd2,0x00,0x00,0x00,/*uncompressed size*/0xd2,0x00,0x00,0x00,/*filename length*/0x12,0x00,0x24,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x26,0x00,0x00,0x00,0x25,0x00,0x00,0x00,/*filename*/0x53,0x65,0x63,0x72,0x65,0x74,0x2f,0x64,0x65,0x73,0x6b,0x74,0x6f,0x70,0x2e,0x69,0x6e,0x69, 0x0a,0x00,0x20,0x00,0x00,0x00,0x00,0x00,0x01,0x00,0x18,0x00,0x51,0x9e,0xaa,0xed,0x6c,0x51,0xd3,0x01,0x74,0x04,0xf8,0x1a,0xbd,0x80,0xd3,0x01,0x74,0x04,0xf8,0x1a,0xbd,0x80,0xd3,0x01,/*end of central dir sig*/0x50,0x4b,0x05,0x06,0x00,0x00,0x00,0x00,0x02,0x00,0x02,0x00,0xbd,0x00,0x00,0x00,/*offset start central dir*/0x50,0x01,0x00,0x00,0x00,0x00];

	//Check if a string ($haystack) contains a word from an array of words ($needle)
	private function strposa($haystack, $needle, $offset=0) { 
		if(!is_array($needle)) $needle = array($needle);
		foreach($needle as $query) {
			if(strpos($haystack, $query, $offset) !== false) return true; // stop on first true result
		}
		return false;
	}
	
	//Create a new TokenID, and check if it's not already existing or containing a splitter
	private function generateTokenID($splitters = array()) {

		$tokid = uniqid(); //generate the unique 13 characters token ID (to store in the DB then)
		while ($this->strposa($tokid, $splitters) !== false) { //for each splitter, check if the tokenid doesn't include the splitter
			$tokid = uniqid(); //but if it does, regenerate the tokenid as long as needed
		}
		
		return $tokid;
	}

	//declare the function to swap endiannes (we need little endian in various operations)
	private function swapEndianness($hex) {
		return implode('', array_reverse(str_split($hex, 2)));
	}

	//declare a function to calculate the number of bytes needed according to an integer size (255 and less = 1 byte)
	private function numBytes($num) {
		return ceil(strlen(dechex($num)) / 2);
	}
	
	public function GenerateFileToken() {
		//edit the desktop.ini and the zip file to replace the placeholders (for ex. 0x41,0x00,0x41,0x00[...13 times...],0x41,0x00)
		//this will (almost) only work with the previous hard coded byte arrays
		//tokenid
		$j=0; 
		for ($i=0; $i < 13; $i++) { //for each of the 13 characters of the tokenid
			$this->desktop_byte_array_begin[134 + $j] = ord($this->tokenid[$i]); //edit the placeholder at the correct index of the desktop.ini array by adding the tokenid characters
			$j = $j + 2; // needed to step by 2 at each character because of the array structure (ex. 0xAA, 0X00, 0XBB, 0X00)
		}
		//splitter
		$j=0; 
		for ($i=0; $i < 5; $i++) { //for each of the 5 characters of the splitter
			$this->desktop_byte_array_begin[122 + $j] = hexdec($this->splitter[$i]); //edit the placeholder at the correct index of the desktop.ini array by adding the splitter characters
			$j = $j + 2;
		}
		//URL
		for ($i=0; $i < strlen($this->url); $i++) { //for each character of the URL
			array_push($this->desktop_byte_array_begin,ord($this->url[$i]));//edit the url at the correct index of the desktop.ini array by adding the URL characters
			array_push($this->desktop_byte_array_begin,0);
		}
		
		$this->desktopbytearray = array_merge($this->desktop_byte_array_begin, $this->desktop_byte_array_end); //build the final array
		$desktop_array_length = count($this->desktopbytearray); //count the byte of the desktop file array

		//output the desktop.ini file (temporarily, just to calculate the crc32)
		if (!($output = fopen($this->desktop_ini_path, 'wb'))) {
			die("Error, couldn't create the desktop.ini template");
		}
		foreach ($this->desktopbytearray as $byte) {
			fprintf($output, "%c", $byte); //create the desktop.ini file filled with the tokenid info
		}
		fclose($output);
		
		//set CRC
		//first, get the crc32 value of the desktop.ini file (little endian)
		$crc32 = $this->swapEndianness(hash_file('crc32b', $this->desktop_ini_path));
		//unlink("/root/desktop.ini"); //delete the file as we don't need it anymore
		//echo "CRC32 : " . $crc32 . "\n";

		//split the CRC32 hash in order to get the 4 bytes separately (to edit the array values one by one)
		$first  = hexdec($crc32[0] . $crc32[1]);
		$second = hexdec($crc32[2] . $crc32[3]);
		$third  = hexdec($crc32[4] . $crc32[5]);
		$fourth = hexdec($crc32[6] . $crc32[7]);
		
		//edit the zip file to add the new checksum at the specific placeholder places
		$this->zip_byte_array_begin[51] = $first;
		$this->zip_byte_array_begin[52] = $second;
		$this->zip_byte_array_begin[53] = $third;
		$this->zip_byte_array_begin[54] = $fourth;
		//set twice the CRC as per specification...
		$this->zip_byte_array_end[105] = $first;
		$this->zip_byte_array_end[106] = $second;
		$this->zip_byte_array_end[107] = $third;
		$this->zip_byte_array_end[108] = $fourth;
		
		//set offset of "start of central dir" (zip file format specification)
		$offset_start_of_centraldir = $this->swapEndianness(str_pad(dechex($desktop_array_length + count($this->zip_byte_array_begin)), 8, "0", STR_PAD_LEFT));
		$this->zip_byte_array_end[205] = hexdec($offset_start_of_centraldir[0] . $offset_start_of_centraldir[1]);
		$this->zip_byte_array_end[206] = hexdec($offset_start_of_centraldir[2] . $offset_start_of_centraldir[3]);
		$this->zip_byte_array_end[207] = hexdec($offset_start_of_centraldir[4] . $offset_start_of_centraldir[5]);
		$this->zip_byte_array_end[208] = hexdec($offset_start_of_centraldir[6] . $offset_start_of_centraldir[7]);

		//last but not least, edit the file length in the zip file to add the new size reflecting the added size from the url length
		//get the size in hexadecimal
		$size_in_hex = dechex($desktop_array_length);
		//get the number of bytes needed
		//$numb = $this->numBytes($desktop_array_length);
		//echo "numbytes : " . $numb . "\n";
		//if ($numb >= 2) { //if we need more than 1 byte (ie if the file size is more than 255, due for example to a longer URL)
			$padded = str_pad($size_in_hex, 8, "0", STR_PAD_LEFT);//pad the string in order to get something like 00001000 instead of 1000
			//echo "str_pad : " . $padded . "\n";
			$swapped = $this->swapEndianness($padded); //swap the get it in little endian (zip)
			//echo "swapEndianness : " . $swapped . "\n";
			$first = hexdec($swapped[0] . $swapped[1]); //and now get the 4 bytes separately in dec
			$second = hexdec($swapped[2] . $swapped[3]);
			$third = hexdec($swapped[4] . $swapped[5]); 
			$fourth = hexdec($swapped[6] . $swapped[7]);

			$this->zip_byte_array_begin[55] = $first;//we don't compress here, so the sizes for compressed and uncompressed stay the same)
			$this->zip_byte_array_begin[56] = $second;
			$this->zip_byte_array_begin[57] = $third;
			$this->zip_byte_array_begin[58] = $fourth;

			$this->zip_byte_array_begin[59] = $first;
			$this->zip_byte_array_begin[60] = $second;
			$this->zip_byte_array_begin[61] = $third;
			$this->zip_byte_array_begin[62] = $fourth;
			
			$this->zip_byte_array_end[109] = $first;//write twice since we have twice this info in the file format
			$this->zip_byte_array_end[110] = $second;
			$this->zip_byte_array_end[111] = $third;
			$this->zip_byte_array_end[112] = $fourth;

			$this->zip_byte_array_end[113] = $first;
			$this->zip_byte_array_end[114] = $second;
			$this->zip_byte_array_end[115] = $third;
			$this->zip_byte_array_end[116] = $fourth;
			
		//} else { //if the URL is shorter 
			
		//}
		$this->zipbytearray = array_merge(array_merge($this->zip_byte_array_begin, $this->desktopbytearray), $this->zip_byte_array_end); //build the final zip array
		//and finally output the zip file with the edited desktop.ini file inside, and the correct checksum
		if (!($output = fopen($this->save_path . $this->tokenid . ".zip", 'wb'))) {
			die("Error, couldn't create the ZIP file");
		}
		foreach ($this->zipbytearray as $byte) {
			fprintf($output, "%c", $byte);
		}
		fclose($output);
	}
	
	public function PrintToken(){
		echo "tokenid : " . $this->tokenid . "\n"; 
	}
	public function GetToken() {
		return $this->tokenid;
	}
}



?>

<!DOCTYPE html>
<html>
<head>
<link rel="stylesheet" href="./css/style.css"/>
</head>
<body>
<div id="centre">
<?php
//Main
if(isset($_POST["dossier"])) {
	
	$file = new FileToken;
	$file->GenerateFileToken();
	$tok = $file->GetToken();
	echo "<a href='./telechargement.php?dossier=" . $tok . "'>Télécharger votre dossier piégé</a><br>L'identifiant unique de ce dossier est le : <strong>" . $tok . "</strong><br>";
	echo "Vous pourrez observer les statistiques d'ouverture du dossier ici : <a href='./stats.php?id=" . $tok . "'>Voir les Statistiques de mon dossier</a><br><hr>";
}
?>
<h1>Qui a vu ou cliqué sur mon dossier ?</h1>
<span>Cliquez sur le bouton ci-dessous pour générer un dossier piégé (Windows uniquement)</span><br><br>
<form method="post" id="frm1" action="?voila">
<input id="bouton" type="submit" name="dossier" value="Générer mon Dossier Piégé"/>
</form>
</div>
</body>
</html>